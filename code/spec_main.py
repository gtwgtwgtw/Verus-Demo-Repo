from openai import AzureOpenAI
import sys

aoai_api_key="6mKL6q3U9UDbRZuJksQFcbW7EuJZ42qhxQWEHhLfQvvSUkOWDMMsJQQJ99BDACHYHv6XJ3w3AAAAACOGzX5o"
aoai_base_url="https://ai-chuyue997439ai270460324416.cognitiveservices.azure.com/"


client_azure = AzureOpenAI(
    azure_endpoint=aoai_base_url,
    api_key=aoai_api_key,
    api_version='2024-12-01-preview'
)

from hashlib import md5
import os
def infer_llm(system: str, user: str, model: str):
    key = md5((system + user + model).encode()).hexdigest()
    print(key, flush=True)
    cache_loc = os.path.join("cache", key)
    if os.path.exists(cache_loc):
        print('hit')
        with open(cache_loc, "r") as f:
            return f.read()

    print('miss')
    response = client_azure.chat.completions.create(
        messages=[
            {"role": "system", "content": system},
            {"role": "user", "content": user}
        ],
        model=model,
    ).choices[0].message.content

    with open(cache_loc, "w") as f:
        f.write(response)
    return response


require_keyword = '[Require Synthesized]'
len_require_keyword = len(require_keyword)
ensures_keyword = '[Ensures Synthesized]'
len_ensures_keyword = len(ensures_keyword)
def parse_result(response: str):
    pos = response.find(require_keyword)
    req = ''
    if pos != -1:
        pos += len_require_keyword
        end_pos = response.find('[End Require]', pos)
        if end_pos != -1:
            req = response[pos:end_pos]
    
    pos = response.find(ensures_keyword)
    ens = ''
    if pos != -1:
        pos += len_ensures_keyword
        end_pos = response.find('[End Ensures]', pos)
        if end_pos != -1:
            ens = response[pos:end_pos]

    return req, ens


SYSTEM = (
"""
You are an expert at Verus, a formal verification tool for Rust. You will be given a Verus code, with a docstring at the beginning that showing the functionality of the code.

Your goal is to fill in requires and ensures clauses in a given verus program, and make sure that the requires and ensures align the docstring at the beginning. 

The to-be-filled requires (or ensures) part have been tagged with // [Add Requires (or Ensures) Clauses Here] in the code.

Output in the following format:
[Require Synthesized]
<requires clause 1>,
<requires clause 2>,
...
<requires clause n>
[End Require]
[Ensures Synthesized]
<ensures clause 1>,
<ensures clause 2>,
...
<ensures clause n>
[End Ensures]


After you have synthesized these clauses, I will fill these clauses into the code as.
```verus
requires
<requires clauses you synthesized here>
ensures
<ensures clauses you synthesized here>
```

Thus, NEVER synthesize the clauses beginnin with `requires` and `ensures`.

Important notes:
- Think over to guarantee the correctness of the code, and make sure that the requires and ensures clauses are correct.
"""
)

SYSTEM_REPAIR = (
"""
You are an expert at Verus, a formal verification tool for Rust. You will be given:
(1) a Verus code, with a docstring at the beginning that showing the functionality of the code.
(2) The error message from the Verus compiler, which indicates the verification failure.
(3) Previous Failure Code generated by LLM.


Your goal is to repair the code so that:
(1) The code can pass the verification.
(2) The code meets the functionality described in the docstring.

Output in the following format:
```verus
<your repaired code here>
```

Important notes:
- Think over to guarantee the correctness of the code.
"""
)

import subprocess

def wrap(text, header):
    return f'{header}\n{text.strip()}'

def print_failures(failures):
    ans = '### Previous Failures: \n\n'
    for code, log in failures:
        ans += ('### Generated Code:') + '\n\n'
        ans += (code) + '\n\n'
        ans += ('### Error Message:') + '\n\n'
        ans += (log) + '\n\n'
    return ans

def run(file_path: str):
    with open(file_path, 'r') as f:
        code = f.read()
    
    docstring = code[:code.find('*/')+2]
    code = code[code.find('*/')+2:]

    failures = []

    final_path = f'../result/final-result-{sys.argv[1]}.rs'

    with open(final_path, 'w') as f:
        f.write(docstring + code)

    for i in range(10):
        subprocess.run(
            f'verus {final_path} > ../tmp/verus.log 2>&1',
            shell=True
        )

        with open('../tmp/verus.log', 'r') as f:
            log = f.read()
        if 'error' not in log and 'Error' not in log:
            print('Verification passed')
            break
        
        with open(final_path, 'r') as f:
            code = f.read()
        failures += [(code, log)]
        
        if code.find('// [Add Requires Clauses Here]') != -1 or code.find('// [Add Ensures Clauses Here]') != -1:
            response = infer_llm(SYSTEM, docstring + code, "o1")
            req, ens = parse_result(response)
            code = code.replace('// [Add Requires Clauses Here]', 
                            wrap(req, 'requires'))
            code = code.replace('// [Add Ensures Clauses Here]', 
                            wrap(ens, 'ensures'))
        else:
            user = docstring + code + 'Error Message:\n\n' + log + '\n\n' + print_failures(failures[1:-2])
            print(user)
            sys.exit(1)
            response = infer_llm(SYSTEM_REPAIR, user, "o1")
            code = response[response.rfind('```verus')+len('```verus'):response.rfind('```')].strip()

        with open(f'../result/intermediate-{sys.argv[1]}.rs', 'w') as f:
            f.write(docstring + code)

        subprocess.run(
            f'python3 main.py --input ../result/intermediate-{sys.argv[1]}.rs > autoverus.log 2>&1',
            shell=True,
            text=True
        )

        with open('output.rs', 'r') as f:
            code = f.read()

        if not code.startswith(docstring):
            code = docstring + '\n' + code

        with open(final_path, 'w') as f:
            f.write(code)

         
if __name__ == '__main__':
    run(f'../test/{sys.argv[1]}.rs')